# -*- coding: utf-8 -*-
"""gp_assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/hse-aml/bayesian-methods-for-ml/blob/master/week6/gp_assignment.ipynb

# First things first
Click **File -> Save a copy in Drive** and click **Open in new tab** in the pop-up window to save your progress in Google Drive.

# Gaussian processes and Bayesian optimization

In this assignment you will learn how to use <a href="http://sheffieldml.github.io/GPy/">GPy</a> and <a href="http://sheffieldml.github.io/GPyOpt/">GPyOpt</a> libraries to deal with gaussian processes. These libraries provide quite simple and inuitive interfaces for training and inference, and we will try to get familiar with them in a few tasks.

### Setup
Load auxiliary files and then install and import the necessary libraries.
"""

try:
    import google.colab
    IN_COLAB = True
except:
    IN_COLAB = False
if IN_COLAB:
    print("Downloading Colab files")
    ! shred -u setup_google_colab.py
    ! wget https://raw.githubusercontent.com/hse-aml/bayesian-methods-for-ml/master/setup_google_colab.py -O setup_google_colab.py
    import setup_google_colab
    setup_google_colab.load_data_week6()

! pip install GPy gpyopt xgboost

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import GPy
import GPyOpt
import matplotlib.pyplot as plt
from sklearn.svm import SVR
import sklearn.datasets
from xgboost import XGBRegressor
from sklearn.model_selection import cross_val_score
import time
from w6_grader import GPGrader
# %matplotlib inline

"""### Grading
We will create a grader instace below and use it to collect your answers. Note that these outputs will be stored locally inside grader and will be uploaded to platform only after running submiting function in the last part of this assignment. If you want to make partial submission, you can run that cell any time you want.
"""

grader = GPGrader()

"""## Gaussian processes: GPy (<a href="http://pythonhosted.org/GPy/">documentation</a>)

We will start with a simple regression problem, for which we will try to fit a Gaussian Process with RBF kernel.
"""

def generate_points(n=25, noise_variance=0.0036):
    np.random.seed(777)
    X = np.random.uniform(-3., 3., (n, 1))
    y = np.sin(X) + np.random.randn(n, 1) * noise_variance**0.5
    return X, y
    
def generate_noise(n=25, noise_variance=0.0036):
    np.random.seed(777)
    X = np.random.uniform(-3., 3., (n, 1))
    y = np.random.randn(n, 1) * noise_variance**0.5
    return X, y

# Create data points
X, y = generate_points()
plt.plot(X, y, '.')
plt.show()

"""To fit a Gaussian Process, you will need to define a kernel. For Gaussian (GBF) kernel you can use `GPy.kern.RBF` function.

<b> Task 1.1: </b> Create RBF kernel with variance 1.5 and length-scale parameter 2 for 1D samples and compute value of the kernel between points `X[5]` and `X[9]`. Submit a single number. 
<br><b>Hint:</b> use `.K` property of kernel object.
"""

kernel = GPy.kern.RBF(input_dim=1, variance=1.5, lengthscale=2)

kernel.K(X[5].reshape(-1, 1), X[9].reshape(-1, 1))

kernel = GPy.kern.RBF(input_dim=1, variance=1.5, lengthscale=2)  ### YOUR CODE HERE
kernel_59 =  kernel.K(X[5].reshape(-1, 1), X[9].reshape(-1, 1)) ### YOUR CODE HERE
grader.submit_GPy_1(kernel_59)

"""<b> Task 1.2: </b> Fit GP into generated data. Use kernel from previous task. Submit predicted mean and vairance at position $x=1$.
<br><b>Hint:</b> use `GPy.models.GPRegression` class.
"""

model = GPy.models.GPRegression(X, y, kernel)  ### YOUR CODE HERE
mean, variance = model.predict(np.array([[1]], dtype=float))  ### YOUR CODE HERE
grader.submit_GPy_2(mean, variance)

model.plot()
plt.show()

"""We see that the model didn't fit the data quite well. Let's try to fit kernel and noise parameters automatically as discussed in the lecture! You can see the current parameters below:"""

model

"""<b> Task 1.3: </b> Optimize length-scale, variance and noise component of the model and submit optimal length-scale value of the kernel. 
<br><b>Hint:</b> Use `.optimize()` function of the model and `.lengthscale` property of the kernel.
"""

model.optimize()
model

### YOUR CODE HERE
grader.submit_GPy_3(model.kern.lengthscale)

model.plot()
plt.show()

"""As you see, the process generates outputs just right. Let's see if GP can figure out itself when we try to fit it into noise or signal.

<b> Task 1.4: </b> Generate two datasets: sinusoid wihout noise and samples from gaussian noise. Optimize kernel parameters and submit optimal values of noise component.
<br><b>Note:</b> generate data only using ```generate_points(n, noise_variance)``` and ```generate_noise(n, noise_variance)``` function!
"""

X, y = generate_noise(noise_variance=10)
### YOUR CODE HERE
model1 = GPy.models.GPRegression(X, y, kernel)
model1.optimize()
noise = model1.Gaussian_noise.variance

X, y = generate_points(noise_variance=0)
### YOUR CODE HERE
model2 = GPy.models.GPRegression(X, y, kernel)
model2.optimize()
just_signal = model2.Gaussian_noise.variance

grader.submit_GPy_4(noise, just_signal)

"""## Sparse GP
Now let's consider the speed of GP. We will generate a dataset of 3000 points and measure the time that is consumed for prediction of mean and variance for each point. We will then try to use inducing inputs and find the optimal number of points according to quality-time tradeoff.

For the sparse model with inducing points, you should use ```GPy.models.SparseGPRegression``` class. You can set the number of inducing inputs with parameter ```num_inducing``` and optimize their positions and values with ```.optimize()``` call.

<b>Task 1.5</b>: Create a dataset of 1000 points and fit GPRegression. Measure time for predicting mean and variance at position $x=1$. Then fit `SparseGPRegression` with 10 inducing inputs and repeat the experiment. Report speedup as a ratio between consumed time without and with inducing inputs.
"""

X, y = generate_points(1000)

start = time.time()
### YOUR CODE HERE
gp = GPy.models.GPRegression(X, y, kernel)
mean_gp, var_gp = gp.predict(np.array([[1]], dtype=float))
time_gp = time.time()-start

start = time.time()
### YOUR CODE HERE
sgp = GPy.models.SparseGPRegression(X, y, kernel)
mean_sgp, var_sgp = sgp.predict(np.array([[1]], dtype=float))
time_sgp = time.time()-start

gp.plot()
plt.show()

sgp.plot()
plt.show()

grader.submit_GPy_5(time_gp / time_sgp)

"""## Bayesian optimization: GPyOpt (<a href="http://pythonhosted.org/GPyOpt/">documentation</a>, <a href="http://nbviewer.jupyter.org/github/SheffieldML/GPyOpt/blob/master/manual/index.ipynb">tutorials</a>)

In this part of the assignment, we will try to find optimal hyperparameters to XGBoost model! We will use data from a small competition to speed things up, but keep in mind that the approach works even for large datasets.

We will use diabetes dataset provided in sklearn package.
"""

dataset = sklearn.datasets.load_diabetes()
X = dataset['data']
y = dataset['target']

"""We will use cross-validation score to estimate accuracy and our goal will be to tune: ```max_depth```, ```learning_rate```, ```n_estimators``` parameters. The baseline MSE with default XGBoost parameters is $0.2$. Let's see if we can do better. First, we have to define optimization function and domains."""

# Score. Optimizer will try to find minimum, so we will add a "-" sign.
def f(parameters):
    parameters = parameters[0]
    score = -cross_val_score(
        XGBRegressor(learning_rate=parameters[0],
                     max_depth=int(parameters[2]),
                     n_estimators=int(parameters[3]),
                     gamma=int(parameters[1]),
                     min_child_weight = parameters[4]), 
        X, y, scoring='neg_mean_squared_error'
    ).mean()
    score = np.array(score)
    return score

baseline = -cross_val_score(
    XGBRegressor(), X, y, scoring='neg_mean_squared_error'
).mean()
baseline

# Bounds (NOTE: define continuous variables first, then discrete!)
bounds = [
    {'name': 'learning_rate',
     'type': 'continuous',
     'domain': (0, 1)},

    {'name': 'gamma',
     'type': 'continuous',
     'domain': (0, 5)},

    {'name': 'max_depth',
     'type': 'discrete',
     'domain': (1, 50)},

    {'name': 'n_estimators',
     'type': 'discrete',
     'domain': (1, 300)},

    {'name': 'min_child_weight',
     'type': 'discrete',
     'domain': (1, 10)}
]

np.random.seed(777)
optimizer = GPyOpt.methods.BayesianOptimization(
    f=f, domain=bounds,
    acquisition_type ='MPI',
    acquisition_par = 0.1,
    exact_eval=True
)

max_iter = 50
max_time = 60
optimizer.run_optimization(max_iter, max_time)

optimizer.plot_convergence()

"""Best values of parameters:"""

optimizer.X[np.argmin(optimizer.Y)]

print('MSE:', np.min(optimizer.Y),
      'Gain:', baseline/np.min(optimizer.Y)*100)

"""We were able to get 9% boost without tuning parameters by hand! Let's see if you can do the same.

<b>Task 2.1:</b> Tune SVR model. Find optimal values for three parameters: `C`, `epsilon` and `gamma`. Use range (1e-5, 1000) for `C`, (1e-5, 10) for `epsilon` and `gamma`. Use MPI as an acquisition function with weight 0.1. Submit the optimal value of epsilon that was found by a model.
"""

def svr(parameters):
    parameters = parameters[0]
    score = -cross_val_score(
                    SVR(C=parameters[0], epsilon=parameters[1], gamma=parameters[2]),
                X, y, scoring='neg_mean_squared_error').mean()
    score = np.array(score)
    return score

baseline_svr = -cross_val_score(SVR(), X, y, scoring='neg_mean_squared_error').mean()
baseline_svr

# Bounds (NOTE: define continuous variables first, then discrete!)
bounds_svr = [
    {'name': 'C',
     'type': 'continuous',
     'domain': (1e-5, 1000)},

    {'name': 'epsilon',
     'type': 'continuous',
     'domain': (1e-5, 10)},

    {'name': 'gamma',
     'type': 'continuous',
     'domain': (1e-5, 10)},
]

np.random.seed(777)
optimizer_svr = GPyOpt.methods.BayesianOptimization(
    f=svr, domain=bounds_svr,
    acquisition_type ='MPI',
    acquisition_par = 0.1,
    exact_eval=True
)

max_iter = 100
max_time = 60
optimizer_svr.run_optimization(max_iter, max_time)

optimizer_svr.plot_convergence()

optimizer_svr.X[np.argmin(optimizer_svr.Y)]

### YOUR CODE HERE
best_epsilon = optimizer_svr.X[np.argmin(optimizer_svr.Y)][1]  ### YOUR CODE HERE
grader.submit_GPyOpt_1(best_epsilon)

"""<b>Task 2.2:</b> For the model above submit boost in improvement that you got after tuning hyperparameters (output percents) [e.g. if baseline MSE was 40 and you got 20, output number 200]"""

print('MSE:', np.min(optimizer_svr.Y),
      'Gain:', baseline_svr/np.min(optimizer_svr.Y)*100)

performance_boost = baseline_svr/np.min(optimizer_svr.Y)  ### YOUR CODE HERE
grader.submit_GPyOpt_2(performance_boost*100)

"""# Authorization & Submission
To submit assignment parts to Cousera platform, please, enter your e-mail and token into variables below. You can generate a token on this programming assignment's page. <b>Note:</b> The token expires 30 minutes after generation.
"""

STUDENT_EMAIL = "guipetor@gmail.com"  # EMAIL HERE
STUDENT_TOKEN = "14zKLaU99FDFFKpf"  # TOKEN HERE
grader.status()

"""If you want to submit these answers, run cell below"""

grader.submit(STUDENT_EMAIL, STUDENT_TOKEN)